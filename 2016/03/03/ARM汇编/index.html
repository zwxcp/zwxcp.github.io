<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />









  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="ARM指令集：
ADC 带进位的32位数加法ADD 32位数相加AND 32位数的逻辑与B 在32M空间内的相对跳转指令BIC 32位数的逻辑位清零BKPT 断点指令BL 带链接的相对跳转指令BLX 带链接的切换跳转BX 切换跳转CDP\CDP2 协处理器数据处理操作CLZ 零计数CMN 比较两个数的相反数CMP 32位数比较EOR 32位逻辑异或LDC\LDC2 从协处理器取一个或多个32位值L">
<meta property="og:type" content="article">
<meta property="og:title" content="ARM指令集">
<meta property="og:url" content="http://www.eastcn.me/2016/03/03/ARM汇编/index.html">
<meta property="og:site_name" content="SAR'S BLOG">
<meta property="og:description" content="ARM指令集：
ADC 带进位的32位数加法ADD 32位数相加AND 32位数的逻辑与B 在32M空间内的相对跳转指令BIC 32位数的逻辑位清零BKPT 断点指令BL 带链接的相对跳转指令BLX 带链接的切换跳转BX 切换跳转CDP\CDP2 协处理器数据处理操作CLZ 零计数CMN 比较两个数的相反数CMP 32位数比较EOR 32位逻辑异或LDC\LDC2 从协处理器取一个或多个32位值L">
<meta property="og:updated_time" content="2016-03-03T10:03:05.375Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ARM指令集">
<meta name="twitter:description" content="ARM指令集：
ADC 带进位的32位数加法ADD 32位数相加AND 32位数的逻辑与B 在32M空间内的相对跳转指令BIC 32位数的逻辑位清零BKPT 断点指令BL 带链接的相对跳转指令BLX 带链接的切换跳转BX 切换跳转CDP\CDP2 协处理器数据处理操作CLZ 零计数CMN 比较两个数的相反数CMP 32位数比较EOR 32位逻辑异或LDC\LDC2 从协处理器取一个或多个32位值L">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post',
    motion: true
  };
</script>

  <title> ARM指令集 | SAR'S BLOG </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">SAR'S BLOG</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">just do it!</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-question-circle fa-fw"></i> <br />
            
            留言
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-heartbeat fa-fw"></i> <br />
            
            公益404
          </a>
        </li>
      

      
      
    </ul>
  

  
    <div class="site-search">
      
  
  <form class="site-search-form">
    <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
  </form>


<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'XEiyJwjaqyW-1q_v5hRL','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                ARM指令集
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-03-03T10:47:10+08:00" content="2016-03-03">
              2016-03-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/嵌入式/" itemprop="url" rel="index">
                    <span itemprop="name">嵌入式</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/03/ARM汇编/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/03/ARM汇编/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><p>ARM指令集：</p>
<p>ADC 带进位的32位数加法<br>ADD 32位数相加<br>AND 32位数的逻辑与<br>B 在32M空间内的相对跳转指令<br>BIC 32位数的逻辑位清零<br>BKPT 断点指令<br>BL 带链接的相对跳转指令<br>BLX 带链接的切换跳转<br>BX 切换跳转<br>CDP\CDP2 协处理器数据处理操作<br>CLZ 零计数<br>CMN 比较两个数的相反数<br>CMP 32位数比较<br>EOR 32位逻辑异或<br>LDC\LDC2 从协处理器取一个或多个32位值<br>LDM 从内存送多个32位字到ARM寄存器<br>LDR 从虚拟地址取一个单个的32位值<br>MCR\MCR2\MCRR 从寄存器送数据到协处理器<br>MLA 32位乘累加<br>MOV 传送一个32位数到寄存器<br>MRC\MRC2\MRRC 从协处理器传送数据到寄存器<br>MRS 把状态寄存器的值送到通用寄存器<br>MSR 把通用寄存器的值传送到状态寄存器<br>MUL 32位乘<br>MVN 把一个32位数的逻辑“非”送到寄存器<br>ORR 32位逻辑或<br>PLD 预装载提示指令<br>QADD 有符号32位饱和加<br>QDADD 有符号双32位饱和加<br>QSUB 有符号32位饱和减<br>QDSUB 有符号双32位饱和减<br>RSB 逆向32位减法<br>RSC 带进位的逆向32法减法<br>SBC 带进位的32位减法<br>SMLAxy 有符号乘累加(16位<em>16位)+32位=32位<br>SMLAL 64位有符号乘累加((32位</em>32位)+64位=64位)<br>SMALxy 64位有符号乘累加((32位<em>32位)+64位=64位)<br>SMLAWy 32位有号乘累加((32位</em>16位)&gt;&gt;16位)+32位=32位<br>SMULL 64位有符号乘累加(32位<em>32位)=64位<br>SMULxy 32位有符号乘(16位</em>16位=32位)<br>SMULWy 32位有符号乘(32位<em>16位&gt;&gt;16位=32位)<br>STC\STC2 从协处理器中把一个或多个32位值存到内存<br>STM 把多个32位的寄存器值存放到内存<br>STR 把寄存器的值存到一个内存的虚地址内间<br>SUB 32位减法<br>SWI 软中断<br>SWP 把一个字或者一个字节和一个寄存器值交换<br>TEQ 等值测试<br>TST 位测试<br>UMLAL 64位无符号乘累加((32位</em>32位)+64位=64位)<br>UMULL 64位无符号乘累加(32位*32位)=64位<br>    无论是体系结构还是指令集，大家或多或少都应该对X86汇编有些了解，而对于嵌入式领域已被广泛采用的ARM 处理器，了解的可能并不多。如果你有兴趣从事嵌入式方面的开发，那么了解一些RISC 体系结构和ARM汇编的知识还是有必要的。这里，我们找出了这两种体系结构最明显的不同之处，并对此进行介绍，让大家对于RISC体系结构的汇编有一个基本的了解。首先，我们就来看一看基于RISC的ARM的体系结构。</p>
<p>基于RISC 的ARM CPU<br>ARM是一种RISC体系结构的处理器芯片。和传统的CISC体系结构不同，RISC 有以下的几个特点：<br>◆ 简洁的指令集——为了保证CPU可以在高时钟频率下单周期执行指令，RISC指令集只提供很有限的操作（例如add,sub，mul等），而复杂的操作都需要由这些简单的指令来组合进行模拟。并且，每一条指令不仅执行时间固定，其指令长度也是固定的，这样，在译码阶段就可以对下一条指令进行预取。<br>◆ Load-Store 结构——这个应该是RISC 设计中比较有特点的一部分。在RISC 中，CPU并不会对内存中的数据进行操作，所有的计算都要求在寄存器中完成。而寄存器和内存的通信则由单独的指令来完成。而在CSIC中，CPU是可以直接对内存进行操作的，这也是一个比较特别的地方。<br>◆ 更多的寄存器——和CISC 相比，基于RISC的处理器有更多的通用寄存器可以使用，且每个寄存器都可以进行数据存储或者寻址。<br>     当然，作为RISC 领域最成功的处理器，ARM也遵从上面的特点。这里，我们不妨来看一看在user 模式下，ARM处理器的体系结构，这对于我们了解其汇编语言是有好处的。而其它模式下只是有一些寄存器分组略有不同，大家可以在ARM的手册上查到。这里要说明的是，尽管ARM处理器也支持16位指令，不过在下文中，我们都假定ARM处理器在32 位模式下工作。</p>
<p>图：user模式下ARM处理器体系结构<br>      从图中我们看到，在user 模式下，ARM CPU 有16个数据寄存器，被命名为r0~r15(这个要比x86的多一些)。r13~r15有特殊用途，其中：<br>◆ r13 - 指向当前栈顶，相当于x86的esp,这个东西在汇编指令中要用sp 表示<br>◆ r14 - 称作链接寄存器，指向函数的返回地址。用lr表示，这和x86将返回地址保存在栈中是不同的<br>◆ r15 - 类似于x86的eip，其值等于当前正在执行的指令的地址+8(因为在取址和执行之间多了一个译码的阶段)，这个用pc表示<br>      另外，ARM处理器还有一个名为cspr的寄存器，用来监视和控制内部操作，这点和x86 的状态寄存器是类似的。具体的内容就用到再说了。</p>
<p>ARM 指令集<br>ARM处理器可以支持3种指令集——ARM，Thumb和Jazelle。<br>采用那种指令集，由cspr中的标志位来决定。大体说来：<br>◆ ARM——这是ARM自身的32 位指令集<br>◆ Thumb ——这是一个全16 位的指令集，在16 位外部数据总线宽度下，这个指令集的效率要比32 位的ARM指令高一些。<br>◆ Jazelle ——这是一个8位指令集，用来加速Java字节码的执行<br>      整个ARM指令集由数据处理指令、分支指令、Load-Store指令、程序中断指令和一些系统控制指令构成，除了Load-Store指令外，其他部分和x86指令集是比较类似的。但和x86相比，ARM指令最显著的特点它们都是32-bit 定长的。另外，由于arm是基于RISC指令集的，所以CPU只处理在寄存器中的数据并通过独立的load-store指令在内存和寄存器之间进行数据的传递。<br>       在使用方面，ARM指令的格式也要比Intel的复杂些。一般说来，一条ARM指令有如下的形式：</p>
<p><instruction> {S} [Rd], [Rn], [Rm]<br>其中：</instruction></p>
<ul>
<li>{S} —— 加上这个后缀的指令会更新cpsr 寄存器</li>
<li>[Rd] —— 目的寄存器</li>
<li>[Rn]/[Rm] —— 源寄存器<br>一般来说，arm 指令有3个操作数，其中Rm寄存器在执行指令前可以进入桶形移位器进行移位操作，而Rn则会直接进入ALU 单元。如果一条arm 指令只有2 个操作数，那么源寄存器按照Rm 来处理。例如，一条加法指令：<br>add r0, r1, #1<br>就会把r1+1的结果存放到r0中。<pre><code>在熟悉了基本的汇编格式后，读者就可以自行去查询基本的ARM汇编指令了，下面，我们找出ARM中比较有特色部分——Load-Store指令结构，它是CPU 和内存进行通信的一个重要媒介。
</code></pre></li>
</ul>
<p>Load-Store 指令体系<br>       由于ARM CPU并不直接处理内存中的数据，这个指令体系就担起了在寄存器和内存之间交换数据的重要媒介。它要比x86 的内存访问机制复杂一些。该指令体系分成3 类：<br>◆ 单寄存器传输(这是与x86 最为相像的)<br>◆ 多寄存器传输<br>◆ 交换指令</p>
<p>单寄存器传输<br>先看第一个，很简单：把单一的数据传入(LDR) 或传出(STR)寄存器，对内存的访问可以是DWORD(32-bit), WORD(16-bit)和BYTE(8-bit)。指令的格式如下：<br>DWORD:</p>
<p><ldr |="" str=""> Rd, addressing1<br>WORD:</ldr></p>
<p><ldr |="" str=""> H Rd, addressing2 无符号版</ldr></p>
<p><ldr> SH Rd, addressing2 有符号版<br>BYTE:</ldr></p>
<p><ldr |="" str=""> B Rd, addressing1 无符号版</ldr></p>
<p><ldr> SB Rd, addressing2 有符号版<br>addressing1 和addressing2 的分类下面再说，现在理解成某种寻址方式就可以了。<br>在单寄存器传输方面，还有以下三种变址模式，他们是：<br>◆ preindex<br>这种变址方式和x86的寻址机制是很类似的,先对寄存器进行运算,然后寻址,但是在寻之后,基址寄存器的内容并不发生改变,例如:<br>ldr r0, [r1, #4]<br>的含义就是把r1+4 这个地址处的DOWRD 加载到r0，而寻址后，r1 的内容并不改变。<br>◆ preindex with writeback<br>这种变址方式有点类似于++i的含义,寻址前先对基地址寄存器进行运算,然后寻址. 其基本的语法是在寻址符[]后面加上一个”!” 来表示.例如:<br>ldr r0, [r1, #4]!<br>就可以分解成：<br>add r1, r1, #4<br>ldr r0, [r1, #0]<br>◆ postindex<br>自然这种变址方式和i++的方式就很类似了,先利用基址寄存器进行寻址,然后对基址寄存器进行运算,其基本语法是把offset 部分放到[]外面,例如:<br>ldr r0, [r1], #4<br>就可以分解成：<br>ldr r0, [r1, #0]<br>add r1, r1, #4<br>如果你还记得x86 的SIB 操作的话，那么你一定想ARM是否也有，答案是有也没有。在ss上面提到的addressing1 和addressing2的区别就是比例寄存器的使用,addressing1可以使用[base, scale, 桶形移位器]来实现SB 的效果，或者通过<a href="这里的offset 可以是立即数或者寄存器">base,offset</a>来实现SI 的效果,而addressing2则只能用后者了。于是每一种变址方式最多可以有3 种寻址方式，这样一来，最多可以有9种用来寻址的指令形式。例如:<br>ldr r0, [r1, r2, LSR #0x04]!<br>ldr r0, [r1, -#0x04]<br>ldr r0, [r1], LSR #0x04<br>每样找了一种，大概就是这个意思。到此，单寄存器传输就结束了，掌握这些足够应付差事了。下面来看看多寄存器传输吧。</ldr></p>
<p>多寄存器传输<br>       说得很明白，意思就是通过一条指令同时把多个寄存器的内容写到内存或者从内存把数据写到寄存器中，效率高的代价是会增加系统的延迟，所以armcc 提供了一个编译器选项来控制寄存器的个数。指令的格式有些复杂：</p>
<p><ldm |="" stm=""> &lt;寻址模式&gt; Rn{!}, <registers>{r^}<br>我们先来搞明白寻址模式，多寄存器传输模式有4 种:<br>也就是说以A开头的都是在Rn的原地开始操作，而B开头的都是以Rn的下一个位置开始操作。如果你仍然感到困惑，我们不妨看个例子。<br>所有的示例指令执行前：<br>mem32[0x1000C] = 0x04<br>mem32[0x10008] = 0x03<br>mem32[0x10004] = 0x02<br>mem32[0x10000] = 0x01<br>r0 = 0x00010010<br>r1 = 0x00000000<br>r3 = 0x00000000<br>r4 = 0x00000000<br>1) ldmia r0!, {r1-r3} 2) ldmib r0!, {r1-r3}<br>执行后:                      执行后:<br>r0 = 0x0010001C    r0 = 0x0010001C<br>r1 = 0x01                   r1 = 0x02<br>r2 = 0x02                   r2 = 0x03<br>r3 = 0x03                   r3 = 0x04<br>至于DA 和DB 的模式，和IA / IB 是类似的，不多说了。<br>最后要说的是，使用ldm 和stm指令对进行寄存器组的保护是很常见和有效的功能。配对方案：<br>stmia / ldmdb<br>stmib / ldmda<br>stmda / ldmib<br>stmdb / ldmia<br>继续来看两个例子：<br>执行前:<br>r0 = 0x00001000<br>r1 = 0x00000003<br>r2 = 0x00000002<br>r3 = 0x00000001<br>执行的指令:<br>stmib r0!, {r1-r3}<br>mov r1, #1 ; These regs have been modified<br>mov r2, #2<br>mov r3, #3<br>当前寄存器状态:<br>r0 = 0x0000100C<br>r1 = 0x00000001<br>r2 = 0x00000002<br>r3 = 0x00000003<br>ldmia r0!, {r1-r3}<br>最后的结果:<br>r0 = 0x00001000<br>r1 = 0x00000003<br>r2 = 0x00000002<br>r3 = 0x00000001<br>另外，我们还可以利用这个指令对完成内存块的高效copy：<br>loop<br>ldmia r9!, {r0-r7}<br>stmia r10!, {r0-r7}<br>cmp r9, r11<br>bne loop<br>说到这里，读者应该对RISC的Load-Store体系结构有一个大概的了解了，能够正确配对使用指令，是很重要的。</registers></ldm></p>
<p>ARM 异常处理<br>如果您阅读ARM手册，您会发现，在ARM中，经常强调Exception（异常）这个概念，在ARM里，Interrupt（中断）也是一种形式的异常。ARM的Exception同其所定义的5种异常模式是密切相关的，CPU在捕获到任何一个Exception后，必定会进入某个异常模式，异常类型及捕获到该异常后CPU所进入的异常模式之间的对应关系是ARM所预先定义好的。<br>如果您对X86比较熟悉，您会发现，不象X86，系统定义了不同的中断，比如键盘中断，鼠标中断等等，并且系统也定义了这些中断所对应的中断向量。ARM没有定义这些，ARM只会告诉你，有外部中断产生，并切换到IRQ或FIQ模式，然后执行IRQ或FIQ所对应的中断向量。至于到底是键盘中断，还是鼠标中断，这得由操作系统提供的中断函数自己去判断，比如通过查询中断控制器的某个或某些寄存器。ARM这样做的原因是：ARM只是一个CORE，它并不定义也不去假想其外部环境，这样可以使得ARM CORE更加紧凑和简洁，同时也给SOC设计者提供了更多的灵活性和发挥空间。您一定要相信，ARM被如此广泛使用不是“盖”的，从系统开发者角度看，ARM是一种最简单、最灵活的CPU，它的优雅和简洁性就像C语言一样。呵呵，C语言是我最喜欢的语言。<br>好了，“臭屁”了这么多，我们言归正传。对ARM异常处理的研究务必要弄清楚以下几个方面：<br>(1) 异常类型<br>(2) 异常类型及处理该异常时CPU的执行模式<br>(3) 异常向量地址<br>(4) 异常处理过程 </p>
<p>异常类型<br>ARM定义了如下类型的异常（江南七怪，这样好记）：<br>（1）   RESET异常：由于执行RESET指令或外部RESET信号产生的异常<br>（2）   SWI异常：执行SWI指令产生的异常，通常用于提供系统调用接口<br>（3）   IRQ异常：ARM的IRQ Signal被触发所产生的异常<br>（4）   FIQ异常：ARM的FIQ Signal被触发所产生的异常<br>（5）   Prefetch Abort异常：预取指令时产生的异常<br>（6）   Data Abort异常：存取内存数据时产生的异常<br>（7）   Undefined instruction异常：执行unknown指令时产生的异常 </p>
<p>执行模式<br>当产生异常后，CPU会进入相应的异常模式并处理该异常：<br>    （1）   RESET和SWI异常：CPU进入Supervisor模式<br>    （2）   IRQ异常：CPU进入IRQ模式<br>    （3）   FIQ异常：CPU进入FIQ模式<br>    （4）   Prefetch Abort和Data Abort异常：CPU进入Abort模式<br>    （5）   Undefined instruction异常：CPU进入Undefined模式 </p>
<p>向量地址<br>ARM的异常向量地址可以处于4G物理空间的低端（0x00000000起），也可以处于高端（0xffff0000起），具体是哪种情况，根据具体的CPU及其配置而定。下面是7种异常的向量地址（挎弧内为高端情形）：<br>（1）   RESET异常：0x00000000   (0xffff0000)<br>（2）   Undefined instruction异常： 0x00000004 (0xffff0004)<br>（3）   SWI异常：0x00000008 (0xffff0008)<br>（4）   Prefetch Abort异常： 0x0000000c (0xffff000c)<br>（5）   Data Abort异常： 0x00000010 (0xffff0010)<br>（6）   IRQ异常： 0x00000018 (0xffff0018)<br>（7）   FIQ异常： 0x0000001c (0xffff001c) </p>
<p>每个中断向量为4字节，一般的操作系统在该地址处放置一条跳转指令“LDR PC，终端处理函数地址”。另外要注意的是，在IRQ异常和Data Abort异常之间空了4个字节，这4个字节是保留的。</p>
<p>处理过程<br>   处理过程包括两个部分：<br>    （1）   进入：这个过程由CPU负责<br>    （2）   退出：这个过程由OS负责 </p>
<p>   在捕获到某个异常后，启动“进入”过程，该过程内CPU执行如下动作：<br>    （1） 将当前PC的值（或PC + 4，或PC + 8）保存到R14的某个影子寄存器中。到底选择哪个影子寄存器由该异常的执行模式而定；另外R14影子寄存器的值同异常类型相关。比如Data Abort异常，对应的影子寄存器就是Abort模式的影子寄存器R14_abt，R14_abt的值为异常产生时PC值 + 8。<br>    （2） 将CPSR保存到CPSR的某个影子寄存器SPSR中，同样，具体选择哪个影子寄存器由该异常的执行模式而定。<br>    （3）       执行对因的中断向量 </p>
<pre><code>退出过程由操作系统自己负责，只要确保退出后的PC和CPSR同进入之前是一样就可以了。有时候操作系统在处理某种特定情况的异常后会将退出后PC值变为进入前PC值 + 4（即下一条指令地址），这仅仅是一个提醒，其目的是说明退出过程是完全由软件自己决定的。
</code></pre><p>Linux BOOTLOADER全程详解</p>
<p>网上关于Linux的BOOTLOADER文章不少了,但是大都是vivi,blob等比较庞大的程序,读起来不太方便,编译出的文件也比较大,而且更多的是面向开发用的引导代码,做成产品时还要裁减,这一定程度影响了开发速度,对初学者学习开销也比较大,在此分析一种简单的BOOTLOADER,是在三星公司提供的2410BOOTLOADER上稍微修改后的结果,编译出来的文件大小不超过4k,希望对大家有所帮助.<br>1.几个重要的概念<br>COMPRESSED KERNEL and DECOMPRESSED KERNEL<br>压缩后的KERNEL,按照文档资料,现在不提倡使用DECOMPRESSED KERNEL,而要使用COMPRESSED KERNEL,它包括了解压器.因此要在ram分配时给压缩和解压的KERNEL提供足够空间,这样它们不会相互覆盖.当执行指令跳转到 COMPRESSED KERNEL后,解压器就开始工作,如果解压器探测到解压的代码会覆盖掉COMPRESSED KERNEL,那它会直接跳到COMPRESSED KERNEL后存放数据,并且重新定位KERNEL,所以如果没有足够空间,就会出错.</p>
<p>Jffs2 File System<br>可以使armlinux应用中产生的数据保存在FLASH上,我的板子还没用到这个. </p>
<p>RAMDISK<br>使用RAMDISK可以使ROOT FILE SYSTEM在没有其他设备的情况下启动.一般有两种加载方式,我就介绍最常用的吧,把COMPRESSED RAMDISK IMAGE放到指定地址,然后由BOOTLOADER把这个地址通过启动参数的方式ATAG_INITRD2传递给KERNEL.具体看代码分析.</p>
<p>启动参数(摘自IBM developer)<br>在调用内核之前，应该作一步准备工作，即：设置 Linux 内核的启动参数。Linux 2.4.x 以后的内核都期望以标记列表(tagged list)的形式来传递启动参数。启动参数标记列表以标记 ATAG_CORE 开始，以标记 ATAG_NONE 结束。每个标记由标识被传递参数的 tag_header 结构以及随后的参数值数据结构来组成。数据结构 tag 和 tag_header 定义在Linux 内核源码的include/asm/setup.h 头文件中.<br>在嵌入式 Linux 系统中，通常需要由 BOOTLOADER 设置的常见启动参数有：ATAG_CORE、ATAG_MEM、ATAG_CMDLINE、ATAG_RAMDISK、ATAG_INITRD等。<br>(注)参数也可以用COMMANDLINE来设定,在我的BOOTLOADER里,我两种都用了. </p>
<p>2.开发环境和开发板配置:<br>CPU:S3C2410,BANK6上有64M的SDRAM(两块),BANK0上有32M NOR FLASH,串口当然是逃不掉的.这样,按照数据手册,地址分配如下:<br>0x4000_0000开始是4k的片内DRAM.<br>0x0000_0000开始是32M FLASH 16bit宽度<br>0x3000_0000开始是64M SDRAM 32bit宽度<br>注意:控制寄存器中的BANK6和BANK7部分必须相同.<br>0x4000_0000(片内DRAM)存放4k以内的BOOTLOADER IMAGE<br>0x3000_0100开始存放启动参数<br>0x3120_0000 存放COMPRESSED KERNEL IMAGE<br>0x3200_0000 存放COMPRESSED RAMDISK<br>0x3000_8000 指定为DECOMPRESSED KERNEL IMAGE ADDRESS<br>0x3040_0000 指定为DECOMPRESSED RAMDISK IMAGE ADDRESS<br>开发环境:Redhat Linux,armgcc toolchain, armlinux KERNEL<br>如何建立armgcc的编译环境:建议使用toolchain,而不要自己去编译armgcc,偶试过好多次,都以失败告终.<br>先下载arm-gcc 3.3.2 toolchain<br>将arm-linux-gcc-3.3.2.tar.bz2 解压到 /toolchain </p>
<h1 id="tar_jxvf_arm-linux-gcc-3-3-2-tar-bz2"><a href="#tar_jxvf_arm-linux-gcc-3-3-2-tar-bz2" class="headerlink" title="tar jxvf arm-linux-gcc-3.3.2.tar.bz2"></a>tar jxvf arm-linux-gcc-3.3.2.tar.bz2</h1><h1 id="mv_/usr/local/arm/3-3-2_/toolchain"><a href="#mv_/usr/local/arm/3-3-2_/toolchain" class="headerlink" title="mv /usr/local/arm/3.3.2 /toolchain"></a>mv /usr/local/arm/3.3.2 /toolchain</h1><p>在makefile 中在把arch=arm CROSS_COMPILE设置成toolchain的路径还有就是INCLUDE = -I ../include -I /root/my/usr/local/arm/3.3.2/include.,否则库函数就不能用了<br>3.启动方式:<br>可以放在FLASH里启动,或者用Jtag仿真器.由于使用NOR FLASH,根据2410的手册,片内的4K DRAM在不需要设置便可以直接使用,而其他存储器必须先初始化,比如告诉memory controller,BANK6里有两块SDRAM,数据宽度是32bit,= =.否则memory control会按照复位后的默认值来处理存储器.这样读写就会产生错误.<br>所以第一步,通过仿真器把执行代码放到0x4000_0000,(在编译的时候,设定TEXT_BASE=0x40000000)<br>第二步,通过 AxD把linux KERNEL IMAGE放到目标地址(SDRAM)中,等待调用<br>第三步,执行BOOTLOADER代码,从串口得到调试数据,引导armlinux </p>
<p>4.代码分析<br>讲了那么多执行的步骤,是想让大家对启动有个大概印象,接着就是BOOTLOADER内部的代码分析了,BOOTLOADER文章内容网上很多,我这里精简了下,删除了不必要的功能.<br>BOOTLOADER一般分为2部分,汇编部分和c语言部分,汇编部分执行简单的硬件初始化,C部分负责复制数据,设置启动参数,串口通信等功能.<br>BOOTLOADER的生命周期: </p>
<ol>
<li>初始化硬件,比如设置UART(至少设置一个),检测存储器= =. </li>
<li>设置启动参数,这是为了告诉内核硬件的信息,比如用哪个启动界面,波特率 = =. </li>
<li>跳转到Linux KERNEL的首地址. </li>
<li>消亡<br>当然,在引导阶段,象vivi等,都用虚地址,如果你嫌烦的话,就用实地址,都一样.<br>我们来看代码:<br>2410init.s<br>.global _start//开始执行处<br>_start:<br>//下面是中断向量<br>b reset @ Supervisor Mode//重新启动后的跳转<br>⋯⋯<br>⋯⋯<br>reset:<br>ldr r0,=WTCON /WTCON地址为53000000,watchdog的控制寄存器 <em>/<br>ldr r1,=0x0 /</em>关watchdog<em>/<br>str r1,[r0]<br>ldr r0,=INTMSK<br>ldr r1,=0xffffffff /</em>屏蔽所有中断<em>/<br>str r1,[r0]<br>ldr r0,=INTSUBMSK<br>ldr r1,=0x3ff /</em>子中断也一样<em>/<br>str r1,[r0]<br>/</em>Initialize Ports…for display LED.<em>/<br>ldr r0, =GPFCON<br>ldr r1, =0x55aa<br>str r1, [r0]<br>ldr r0, =GPFUP<br>ldr r1, =0xff<br>str r1, [r0]<br>ldr r0,=GPFDAT<br>ldr r1,=POWEROFFLED1<br>str r1,[r0]<br>/</em> Setup clock Divider control register </li>
</ol>
<ul>
<li>you must configure CLKDIVN before LOCKTIME or MPLL UPLL </li>
<li>because default CLKDIVN 1,1,1 set the SDMRAM Timing Conflictnop </li>
<li>FCLK:HCLK:PCLK = 1:2:4 in this case<br><em>/<br>ldr r0,=CLKDIVN<br>ldr r1,=0x3<br>str r1,[r0]<br>/</em>To reduce PLL lock time, adjust the LOCKTIME register. <em>/<br>ldr r0,=LOCKTIME<br>ldr r1,=0xffffff<br>str r1,[r0]<br>/</em>Configure MPLL <em>/<br>ldr r0,=MPLLCON<br>ldr r1,=((M_MDIV&lt;&lt;12)+(M_PDIV&lt;&lt;4)+M_SDIV) //Fin=12MHz,Fout=203MHz<br>str r1,[r0]<br>ldr r1,=GSTATUS2<br>ldr r10,[r1]<br>tst r10,#OFFRST<br>bne 1000f<br>//以上这段,我没动,就用三星写的了,下面是主要要改的地方<br>/</em> MEMORY C0NTROLLER(MC)设置*/<br>add r0,pc,#MCDATA - (.+8)// r0指向MCDATA地址,那里存放着MC初始化要用到的数据<br>ldr r1,=BWSCON // r1指向MC控制器寄存器的首地址<br>add r2,r0,#52 // 复制次数,偏移52字<br>1: //按照偏移量进行循环复制<br>ldr r3,[r0],#4<br>str r3,[r1],#4<br>cmp r2,r0<br>bne 1b<br>.align 2<br>MCDATA:<br>.word (0+(B1_BWSCON&lt;&lt;4)+(B2_BWSCON&lt;&lt;8)+(B3_BWSCON&lt;&lt;12)+(B4_BWSCON&lt;&lt;16)+(B5_BWSCON&lt;&lt;20)+(B6_BWSCON&lt;&lt;24)+(B7_BWSCON&lt;&lt;28))<br>上面这行就是BWSCON的数据,具体参数意义如下:<br>需要更改设置DW6 和DW7都设置成10,即32bit,DW0 设置成01,即16bit<br>下面都是每个BANK的控制器数据,大都是时钟相关,可以用默认值,设置完MC后,就跳到调用main函数的部分</li>
</ul>
<p>.word ((B0_Tacs&lt;&lt;13)+(B0_Tcos&lt;&lt;11)+(B0_Tacc&lt;&lt;8)+(B0_Tcoh&lt;&lt;6)+(B0_Tah&lt;&lt;4)+(B0_Tacp&lt;&lt;2)+(B0_PMC))<br>.word ((B1_Tacs&lt;&lt;13)+(B1_Tcos&lt;&lt;11)+(B1_Tacc&lt;&lt;8)+(B1_Tcoh&lt;&lt;6)+(B1_Tah&lt;&lt;4)+(B1_Tacp&lt;&lt;2)+(B1_PMC))<br>.word ((B2_Tacs&lt;&lt;13)+(B2_Tcos&lt;&lt;11)+(B2_Tacc&lt;&lt;8)+(B2_Tcoh&lt;&lt;6)+(B2_Tah&lt;&lt;4)+(B2_Tacp&lt;&lt;2)+(B2_PMC))<br>.word ((B3_Tacs&lt;&lt;13)+(B3_Tcos&lt;&lt;11)+(B3_Tacc&lt;&lt;8)+(B3_Tcoh&lt;&lt;6)+(B3_Tah&lt;&lt;4)+(B3_Tacp&lt;&lt;2)+(B3_PMC))<br>.word ((B4_Tacs&lt;&lt;13)+(B4_Tcos&lt;&lt;11)+(B4_Tacc&lt;&lt;8)+(B4_Tcoh&lt;&lt;6)+(B4_Tah&lt;&lt;4)+(B4_Tacp&lt;&lt;2)+(B4_PMC))<br>.word ((B5_Tacs&lt;&lt;13)+(B5_Tcos&lt;&lt;11)+(B5_Tacc&lt;&lt;8)+(B5_Tcoh&lt;&lt;6)+(B5_Tah&lt;&lt;4)+(B5_Tacp&lt;&lt;2)+(B5_PMC))<br>.word ((B6_MT&lt;&lt;15)+(B6_Trcd&lt;&lt;2)+(B6_SCAN))<br>.word ((B7_MT&lt;&lt;15)+(B7_Trcd&lt;&lt;2)+(B7_SCAN))<br>.word ((REFEN&lt;&lt;23)+(TREFMD&lt;&lt;22)+(Trp&lt;&lt;20)+(Trc&lt;&lt;18)+(Tchr&lt;&lt;16)+REFCNT)<br>.word 0xB2 /<em> REFRESH Control Register </em>/<br>.word 0x30 /<em> BANKSIZE Register : Burst Mode </em>/<br>.word 0x30 /<em> SDRAM Mode Register </em>/<br>.align 2<br>.global call_main //调用main函数,函数参数都为0<br>call_main:<br>ldr sp,STACK_START<br>mov fp,#0 /<em> no previous frame, so fp=0</em>/<br>mov a1, #0 /<em> set argc to 0</em>/<br>mov a2, #0 /<em> set argv to NUL</em>/<br>bl main /<em> call main</em>/<br>STACK_START:<br>.word STACK_BASE<br>undefined_instruction:<br>software_interrupt:<br>prefetch_abort:<br>data_abort:<br>not_used:<br>irq:<br>fiq: </p>
<p>/<em>以上是主要的汇编部分,实现了时钟设置,串口设置watchdog关闭,中断关闭功能(如果有需要还可以降频使用),然后转入main</em>/</p>
<p>2410init.c file<br>int main(int argc,char <strong>argv)<br>{<br>u32 test = 0;<br>void (<em>theKERNEL)(int zero, int arch, unsigned long params_addr) = (void (</em>)(int, int, unsigned long))RAM_COMPRESSED_KERNEL<br>_BASE; //压缩后的IMAGE地址<br>int i,k=0;<br>// downPt=(RAM_COMPRESSED_KERNEL_BASE);<br>chkBs=(_RAM_STARTADDRESS);//SDRAM开始的地方<br>// fromPt=(FLASH_LINUXKERNEL);<br>MMU_EnableICache();<br>ChangeClockDivider(1,1); // 1:2:4<br>ChangeMPllValue(M_MDIV,M_PDIV,M_SDIV); //Fin=12MHz FCLK=200MHz<br>Port_Init();//设置I/O端口,在使用com口前,必须调用这个函数,否则通信芯片根本得不到数据<br>Uart_Init(PCLK, 115200);//PCLK使用默认的200000,拨特率115200<br>/<strong><strong><strong><strong>*</strong></strong></strong></strong></strong>(检查ram空间)<strong><strong><strong><strong><em>*</em></strong></strong></strong></strong>/<br>Uart_SendString(“ntLinux S3C2410 Nor BOOTLOADERn”);<br>Uart_SendString(“ntChecking SDRAM 2410loader.c…n”);<br>for(;chkBs&lt;0x33FA0140;chkBs=chkBs+0x4,test++)// </p>
<p>//根据我的经验,最好以一个字节为递增,我们的板子,在256byte递增检测的时候是没问题的,但是<br>//以1byte递增就出错了,第13跟数据线随几的会冒”1”,检测出来是硬件问题,现象如下<br>//用仿真器下代码测试SDRAM，开始没贴28F128A3J FLASH片子，测试结果很好，但在上了FLASH片子//之后，测试数据（data）为0x00000400<br>连续成批写入读出时，操作大约1k左右内存空间就会出错，//而且随机。那个出错数据总是变为0x00002400，数据总线10位和13位又没短路<br>发生。用其他数据//测试比如0x00000200；0x00000800没这问题。dx帮忙。<br>//至今没有解决,所以我用不了Flash.<br>{<br>chkPt1 = chkBs;<br><em>(u32 </em>)chkPt1 = test;//写数据<br>if(<em>(u32 </em>)chkPt1==1024))//读数据和写入的是否一样?<br>{<br>chkPt1 += 4;<br>Led_Display(1);<br>Led_Display(2);<br>Led_Display(3);<br>Led_Display(4);<br>}<br>else<br>goto error;<br>}<br>Uart_SendString(“ntSDRAM Check Successful!ntMemory Maping…”);<br>get_memory_map();<br>//获得可用memory 信息,做成列表,后面会作为启动参数传给KERNEL<br>//所谓内存映射就是指在4GB 物理地址空间中有哪些地址范围被分配用来寻址系统的 RAM 单元。<br>Uart_SendString(“ntMemory Map Successful!n”);<br>//我用仿真器把KERNEL,RAMDISK直接放在SDRAM上,所以下面这段是不需要的,但是如果KERNEL,RAMDISK在FLASH里,那就需要.</p>
<p>/<strong><strong><strong><strong><em>*</em></strong></strong></strong></strong>(copy linux KERNEL)<strong><strong><strong><strong><em>*</em></strong></strong></strong></strong>/<br>Uart_SendString(“tLoading KERNEL IMAGE from FLASH… n “);<br>Uart_SendString(“tand copy KERNEL IMAGE to SDRAM at 0x31000000n”);<br>Uart_SendString(“ttby LEIJUN DONG dongleijun4000@hotmail.com n”);<br>for(k = 0;k &lt; 196608;k++,downPt += 1,fromPt += 1)//3<em>1024</em>1024/32linux KERNEL des,src,length=3M </p>
<ul>
<li>(u32 <em>)downPt = </em> (u32 <em>)fromPt;<br>/<strong><strong><strong><strong>**</strong></strong></strong></strong></em>(load RAMDISK)<strong><strong><strong><strong><em>*</em></strong></strong></strong></strong>/<br>Uart_SendString(“ttloading COMPRESSED RAMDISK…n”);<br>downPt=(RAM_COMPRESSED_RAMDISK_BASE);<br>fromPt=(FLASH_RAMDISK_BASE);<br>for(k = 0;k &lt; 196608;k++,downPt += 1,fromPt += 1)//3<em>1024</em>1024/32linux KERNEL des,src,length=3M </li>
<li>(u32 <em>)downPt = </em> (u32 <em>)fromPt;<br>/<strong>**</strong>jffs2文件系统,在开发中如果用不到FLASH,这段也可以不要<strong><em>**</em></strong>/<br>Uart_SendString(“ttloading jffs2…n”);<br>downPt=(RAM_JFFS2);<br>fromPt=(FLASH_JFFS2);<br>for(k = 0;k &lt; (1024</em>1024/32);k++,downPt += 1,fromPt += 1) </li>
<li>(u32 <em>)downPt = </em> (u32 <em>)fromPt;<br>Uart_SendString( “Load Success…Run…n “);<br>/<strong><strong><strong><strong>**</strong></strong></strong></strong></em>(setup param)<strong><strong><strong><strong><em>*</em></strong></strong></strong></strong>/<br>setup_start_tag();//开始设置启动参数<br>setup_memory_tags();//内存印象<br>setup_commandline_tag(“console=ttyS0,115200n8”);//启动命令行<br>setup_initrd2_tag();//root device<br>setup_RAMDISK_tag();//ramdisk image<br>setup_end_tag();<br>/<em>关I-cache </em>/<br>asm (“mrc p15, 0, %0, c1, c0, 0”: “=r” (i));<br>i &amp;= ~0x1000;<br>asm (“mcr p15, 0, %0, c1, c0, 0”: : “r” (i));<br>/<em> flush I-cache </em>/<br>asm (“mcr p15, 0, %0, c7, c5, 0”: : “r” (i));<br>//下面这行就跳到了COMPRESSED KERNEL的首地址<br>theKERNEL(0, ARCH_NUMBER, (unsigned long *)(RAM_BOOT_PARAMS));<br>//启动kernel时候,I-cache可以开也可以关,r0必须是0,r1必须是CPU型号<br>(可以从linux/arch/arm/tools/mach-types中找到),r2必须是参数的物理开始地址</li>
</ul>
<p>/<strong><strong><strong><strong><em>*</em></strong></strong></strong></strong>END<strong><strong><strong><strong><em>*</em></strong></strong></strong></strong>/<br>error:<br>Uart_SendString(“nnPanic SDRAM check error!n”);<br>return 0;<br>}<br>static void setup_start_tag(void)<br>{<br>params = (struct tag <em>)RAM_BOOT_PARAMS;//启动参数开始的地址<br>params-&gt;hdr.tag = ATAG_CORE;<br>params-&gt;hdr.size = tag_size(tag_core);<br>params-&gt;u.core.flags = 0;<br>params-&gt;u.core.pagesize = 0;<br>params-&gt;u.core.rootdev = 0;<br>params = tag_next(params);<br>}<br>static void setup_memory_tags(void)<br>{<br>int i;<br>for(i = 0; i &lt; NUM_MEM_AREAS; i++) {<br>if(memory_map[i].used) {<br>params-&gt;hdr.tag = ATAG_MEM;<br>params-&gt;hdr.size = tag_size(tag_mem32);<br>params-&gt;u.mem.start = memory_map[i].start;<br>params-&gt;u.mem.size = memory_map[i].len;<br>params = tag_next(params);<br>}<br>}<br>}<br>static void setup_commandline_tag(char </em>commandline)<br>{<br>int i = 0;<br>/* skip non-existent command lines so the kernel will still </p>
<ul>
<li>use its default command line.<br><em>/<br>params-&gt;hdr.tag = ATAG_CMDLINE;<br>params-&gt;hdr.size = 8;<br>//console=ttyS0,115200n8<br>strcpy(params-&gt;u.cmdline.cmdline, p);<br>params = tag_next(params);<br>}<br>static void setup_initrd2_tag(void)<br>{<br>/</em> an ATAG_INITRD node tells the kernel where the compressed </li>
<li>ramdisk can be found. ATAG_RDIMG is a better name, actually.<br><em>/<br>params-&gt;hdr.tag = ATAG_INITRD2;<br>params-&gt;hdr.size = tag_size(tag_initrd);<br>params-&gt;u.initrd.start = RAM_COMPRESSED_RAMDISK_BASE;<br>params-&gt;u.initrd.size = 2047;//k byte<br>params = tag_next(params);<br>}<br>static void setup_ramdisk_tag(void)<br>{<br>/</em> an ATAG_RAMDISK node tells the kernel how large the </li>
<li>decompressed ramdisk will become.<br><em>/<br>params-&gt;hdr.tag = ATAG_RAMDISK;<br>params-&gt;hdr.size = tag_size(tag_ramdisk);<br>params-&gt;u.ramdisk.start = RAM_DECOMPRESSED_RAMDISK_BASE;<br>params-&gt;u.ramdisk.size = 7.8</em>1024; //k byte<br>params-&gt;u.ramdisk.flags = 1; // automatically load ramdisk<br>params = tag_next(params);<br>}<br>static void setup_end_tag(void)<br>{<br>params-&gt;hdr.tag = ATAG_NONE;<br>params-&gt;hdr.size = 0;<br>} void Uart_Init(int pclk,int baud)//串口是很重要的<br>{<br>int i;<br>if(pclk == 0)<br>pclk = PCLK;<br>rUFCON0 = 0x0; //UART channel 0 FIFO control register, FIFO dISAble<br>rUMCON0 = 0x0; //UART chaneel 0 MODEM control register, AFC dISAble<br>//UART0<br>rULCON0 = 0x3; //Line control register : Normal,No parity,1 stop,8 bits<br>下面这段samsung好象写的不太对,但是我按照Normal,No parity,1 stop,8 bits算出来的确是0x245<br>// [10] [9] [8] [7] [6] [5] [4] [3:2] [1:0]<br>// Clock Sel, Tx Int, Rx Int, Rx Time Out, Rx err, Loop-back, Send break, Transmit Mode, Receive Mode<br>// 0 1 0 , 0 1 0 0 , 01 01<br>// PCLK Level Pulse DISAble Generate Normal Normal Interrupt or Polling<br>rUCON0 = 0x245; // Control register<br>rUBRDIV0=( (int)(PCLK/16./ baud) -1 ); //Baud rate divisior register 0<br>delay(10);<br>}<br>经过以上的折腾,接下来就是kernel的活了.能不能启动kernel,得看你编译kernel的水平了.</li>
</ul>
<p>ARM嵌入式入门的建议<br>由于很多人总问这个问题，所以这里做一个总结文档供大家参考。这里必须先说明，以下的步骤都是针对Linux系统的，并不面向WinCE。也许你会注意到，现在做嵌入式的人中，做linux研究的人远比做WinCE的人多，很多产家提供的资料也是以linux为主。我一直很难理解，其实WinCE的界面比linux的界面好看多了，使用起来也很方便，更为重要的是，WinCE的开发和Windows下的开发基本一样，学起来简单得多，但是学linux或者使用linux做嵌入式的人就是远比WinCE多。在和很多工作的人交流时我了解到，他们公司从没考虑使用WinCE，因为成本高，都是使用linux进行开发。我读研究生的的实验室中也没有使用WinCE的，大都研究linux，也有少部分项目使用vxwork，但是就没有听说过使用WinCE的，原因就是开源！当然现在WinCE6.0听说也开源，不过在成本和资源上linux已经有了无人能挡的优势。与此相对应的是，越来越多的电子厂商已经开始使用linux开发产品。举个例子，Google近期开发的智能手机操作系统Android其实就是使用linux-2.6.23内核进行改进得到的。</p>
<p>第一，学习基本的裸机编程。<br>对于学硬件的人而言，必须先对硬件的基本使用方法有感性的认识，更必须深刻认识该硬件的控制方式，如果一开始就学linux系统、学移植那么只会马上就陷入一个很深的漩涡。我在刚刚开始学ARM的时候是选择ARM7（主意是当时ARM9还很贵），学ARM7的时候还是保持着学51单片机的思维，使用ADS去编程，第一个实验就是控制led。学过一段时间ARM的人都会笑这样很笨，实际上也不是，我倒是觉得有这个过程会好很多，因为无论做多复杂的系统最终都会落实到这些最底层的硬件控制，因此对这些硬件的控制有了感性的认识就好很多了<br>学习裸机的编程的同时要好好理解这个硬件的构架、控制原理，这些我称他为理解硬件。所谓的理解硬件就是说，理解这个硬件是怎么组织这么多资源的，这些资源又是怎么由cpu、由编程进行控制的。比如说，s3c2410中有AD转换器，有GPIO（通用IO口），还有nandflash控制器，这些东西都有一些寄存器来控制，这些寄存器都有一个地址，那么这些地址是什么意思？又怎么通过寄存器来控制这些外围设备的运转？还有，norflash内部的每一个单元在这个芯片的内存中都有一个相应的地址单元，那么这些地址与刚刚说的寄存器地址又有什么关系？他们是一样的吗？而与norflash相对应的nandflash内部的储存单元并不是线性排放的，那么s3c2410怎么将nandflash的地址映射在内存空间上进行使用？或者简单地说应该怎么用nandflash？再有，使用ADS进对ARM9行编程时都需要使用到一个初始化的汇编文件，这个文件究竟有什么用？他里面的代码是什么意思？不要这个可以吗？<br>诸如此类都是对硬件的理解，理解了这些东西就对硬件有很深的理解了，这对以后更深一步的学习将有很大的帮助，如果跳过这一步，我相信越往后学越会觉得迷茫，越觉得这写东西深不可测。因为，你的根基没打好。<br>不过先声明一下，本人并没有使用ADS对ARM9进行编程，我是学完ARM7后直接就使用ARM9学linux系统的，因此涉及使用ADS对ARM9进行编程的问题我很难回答^_^，自己去研究研究吧。<br>对于这部分不久将提供一份教程，这个教程中的例程并不是我为我们所代理的板子写的，是我在我们学院实验室拿的，英培特为他们自己 的实验箱写的，不过很有借鉴意义，可以作为一份有价值的参考。</p>
<p>第二，使用linux系统进行一些基本的实验。<br>    在买一套板子的时候一般会提供一些linux的试验例程，好好做一段时间这个吧，这个过程也是很有意义的，也是为进一步的学习积累感性认识，你能想象一个从没有使用过linux系统的人能学好linux的编程吗？好好按照手册上的例程做一做里面的实验，虽然有点娃娃学走路，有点弱智，但是我想很多高手都会经历这个过程。<br>     在这方面我们深蓝科技目前没有计划提供相应的例程，主要是开发板的提供商会提供很丰富的例程，我们不做重复工作，只提供他们没有的、最有价值的东西给大家。</p>
<p>第三，研究完整的linux系统的的运行过程。<br>所谓完整的linux系统包括哪些部分呢？<br>三部分：bootloader、linux kernel（linux内核）、rootfile（根文件系统）。<br>那么这3部分是怎么相互协作来构成这个系统的呢？各自有什么用呢？三者有什么联系？怎么联系？系统的执行流程又是怎么样的呢？搞清楚这个问题你对整个系统的运行就很清楚了，对于下一步制作这个linux系统就打下了另一个重要的根基。介绍这方面的资料网上可以挖掘到几吨，自己好好研究吧。</p>
<p>第四，开始做系统移植。<br>上面说到完整的linux有3部分，而且你也知道了他们之间的关系和作用，那么现在你要做的便是自己动手学会制作这些东西。<br>当然我不可能叫你编写这些代码，这不实现。事实上这个3者都能在网下载到相应的源代码，但是这个源代码不可能下载编译后就能在你的系统上运行，需要很多的修改，直到他能运行在你的板子上，这个修改的过程就叫移植。在进行移植的过程中你要学的东西很多，要懂的相关知识也很多，等你完成了这个过程你会发现你已经算是一个初出茅庐的高手了。<br>在这个过程中如果你很有研究精神的话你必然会想到看源代码。很多书介绍你怎么阅读linux源代码，我不提倡无目的地去看linux源代码，用许三多的话说，这没有意义。等你在做移植的时候你觉得你必须去看源代码时再去找基本好书看看，这里我推荐一本好书倪继利的《linux内核的分析与编程》，这是一本针对linux-2.6.11内核的书，说得很深，建议先提高自己的C语言编程水平再去看。<br>至于每个部分的移植网上也可以找到好多吨的资料，自己研究研究吧，不过要提醒的是，很多介绍自己经验的东西都或多或少有所保留，你按照他说的去做总有一些问题，但是他不会告诉你怎么解决，这时就要靠自己，如果自己都靠不住就找我一起研究研究吧，我也不能保证能解决你的问题，因为我未必遇到过你的问题，不过我相信能给你一点建议，也许有助你解决问题。<br>这一步的最终目的是，从源代码的官方主页上（都是外国的，悲哀）下载标准的源代码包，然后进行修改，最终运行在板子上。<br>盗用阿基米德的一句话：“给我一根网线，我能将linux搞定”。</p>
<p>第五，研究linux驱动程序的编写。<br>移植系统并不是最终的目的，最终的目的是开发产品，做项目，这些都要进行驱动程序的开发。<br>Linux的驱动程序可以说是五花八门，linux2.4和linux2.6的编写有相当大的区别，就是同为linux2.6但是不同版本间的驱动程序也有区别，因此编写linux的驱动程序变都不是那么容易的事情，对于最新版本的驱动程序的编写甚至还没有足够的参考资料。那么我的建议就是使用、移植一个不算很新的版本内核，这样到时学驱动的编程就有足够的资料了。<br>这部分的推荐书籍可以参考另一篇文章《推荐几本学习嵌入式linux的书籍》。</p>
<p>第六，研究应用程序的编写。<br>做作品做项目除了编写驱动程序，最后还要编写应用程序。现在的趋势是图形应用程序的开发，而图形应用程序中用得最多的还是qt/e函数库。我一直就使用这个函数库来开发自己的应用程序，不过我希望你能使用国产的MiniGUI函数库。盗用周杰伦的广告词就是“支持国产，支持MiniGUI”。MiniGUI的编程比较相似Windows下的VC编程，比较容易上手，效果应该说是相当不错的，我曾使用过来开发ARM7的程序。不过MiniGUI最大的不好就是没有像qtopia这样的图形操作平台，这大大限制了他的推广，我曾经幻想过与北京飞漫公司（就是MiniGUI的版权拥有者）合作使用MiniGUI函数库开发像qtopia这样的图形操作平台，不过由于水平有限这只能是幻想了，呵呵。<br>完成这一步你基本就学完了嵌入式linux的全部内容了。</p>
<p>还有一个小小的经验想和大家分享。我在学习嵌入式linux的过程中很少问人，客观原因是身边的老师、同学师兄都没有这方面的高手，主观原因是我不喜欢问人，喜欢自己研究解决问题。这样做有个好处，就是可以提高自己解决问题的能力，因为做这些东西总有很多问题你难以理解，别人也没有这方面的经验，也不是所有问题都有人给你答案，这时必须要自己解决问题，这样，个人的解决问题能力就显得非常关键了。因此我的建议就是一般的问题到网上搜索一下，确实找不到答案了就问问高手，还是不行了就自己去研究，不要一味去等别人帮你解决问题。<br>记住，问题是学习的最好机会。</p>
</span>
      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/12/11/s3c2440-支持RTL8188EU无线网卡(五)/" rel="next" title="s3c2440-支持RTL8188EU无线网卡(五)">
                <i class="fa fa-chevron-left"></i> s3c2440-支持RTL8188EU无线网卡(五)
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/04/10/ARM编程之高效C编程 /" rel="prev" title="ARM编程之高效C编程">
                ARM编程之高效C编程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


        </div>

        


        
  <div class="comments" id="comments">
    
       <!-- ��˵���ۿ� start -->
    <div class="ds-thread" data-thread-key="<%= post.layout %>-<%= post.slug %>" data-title="<%= post.title %>" data-url="<%= page.permalink %>"></div>
    <!-- ��˵���ۿ� end -->
    <!-- ��˵����JS���� start (һ����ҳֻ������һ��) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'<%= config.duoshuo_shortname %>'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- ��˵����JS���� end -->
    
  </div>


      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/uploads/avatar.jpg" alt="sar" itemprop="image"/>
          <p class="site-author-name" itemprop="name">sar</p>
        </div>
        <p class="site-description motion-element" itemprop="description">Don't be afraid to fail, Be afraid not to try!</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">3</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">标签</span>
              
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zwxcp" target="_blank">
                  
                    <i class="fa fa-globe"></i> github
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/chen999" target="_blank">
                  
                    <i class="fa fa-globe"></i> weibo
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#tar_jxvf_arm-linux-gcc-3-3-2-tar-bz2"><span class="nav-number">1.</span> <span class="nav-text">tar jxvf arm-linux-gcc-3.3.2.tar.bz2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mv_/usr/local/arm/3-3-2_/toolchain"><span class="nav-number">2.</span> <span class="nav-text">mv /usr/local/arm/3.3.2 /toolchain</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sar</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zwxcp"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     


    
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.2" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    motionMiddleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');
      if (CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    };
  });
</script>



  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
